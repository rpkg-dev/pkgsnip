# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/pkgsnippets.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = c(".",
                                 "label",
                                 "name",
                                 "path",
                                 "type"))

pkg <- utils::packageName()

#' List all available R Markdown file snippets
#' 
#' This function lists all of the R Markdown snippets shipped with this package, together with the paths where they're located on the filesystem.
#'
#' @return `pkgsnippets::return_label("data")`
#' @family rmdsnips
#' @export
ls_rmd_snippets <- function() {
  
  fs::path_package("snippets/",
                     package = pkg) %>%
    fs::dir_ls(recurse = TRUE,
               type = "file") %>%
    tibble::tibble(path = .) %>%
    dplyr::mutate(name = fs::path_file(path),
                  .before = 1L)
}

#' Get R Markdown snippet file path
#'
#' This function gives the file path to an R Markdown snippet shipped with this package.
#'
#' The snippets can be used anywhere R Markdown input is supported. For example, you can use them as input to knitr's
#' [`child` document option](https://yihui.org/knitr/options/#child-documents):
#'
#' ````rmd
#' ```{r, child = pkgsnippets::rmd_snippet_path("installation-notice_dev-version_gitlab.Rmd")}
#' ```
#' ````
#'
#' Or you can use them in roxygen2's [`@includeRmd` tag](https://roxygen2.r-lib.org/articles/rd.html#including-external--rmd-md-files):
#'
#' ```r
#' #' @includeRmd `r pkgsnippets::rmd_snippet_path("installation-notice_dev-version_gitlab.Rmd")`
#' ```
#'
#' @param name The name of a snippet. Possible values include:
#'   00`r paste0('- ``"', ls_rmd_snippets()$name, '"``')`
#'
#' @return `r pkgsnippets::return_label("path")`
#' @family rmdsnips
#' @export
#'
#' @examples
#' pkgsnippets::rmd_snippet_path("coding-style-notice.Rmd")
rmd_snippet_path <- function(name = ls_rmd_snippets()$name) {
  
  rlang::arg_match(name) %>%
    paste0("snippets/", .) %>%
    fs::path_package(package = pkg) %>%
    fs::path_real()
}

#' Get predefined Markdown snippet
#'
#' @param name The snippet name.
#'
#' @return A character scalar.
#' @family mdsnips
#' @export
md_snippet <- function(name = md_snippets()$name) {
  
  name <- rlang::arg_match(name)
  
  dplyr::filter(.data = md_snippets(),
                name == !!name)$label
  
  
}

#' Get a table of all Markdown snippets included in this package
#'
#' This simply returns a [tibble][tibble::tbl_df] listing all Markdown snippets together with their `name` which can be provided as [md_snippet()]'s `name`
#' argument.
#'
#' Currently, Markdown snippets with the following `names` are available:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' md_snippets() %>%
#'   dplyr::select(-label) %>%
#'   dplyr::mutate(dplyr::across(.fns = ~ paste0(bt, .x, bt))) %>%
#'   pal::pipe_table() %>%
#'   cat()
#' ```
#'
#' @return `r pkgsnippets::return_label("data")`
#' @family mdsnips
#' @export
md_snippets <- function() {
  
  tibble::tribble(
    ~name, ~label,
    "rstudio_addin_hint", paste0("This function is also registered as an [RStudio add-in](https://rstudio.github.io/rstudioaddins/) allowing RStudio users ",
                                 "to assign a custom shortcut to it.")
  )
}

#' Get predefined roxygen2 tag label
#'
#' These are pre-defined labels intended to be used to document functions using [roxygen2][roxygen2::roxygen2]
#' [tags](https://roxygen2.r-lib.org/articles/rd.html#functions).
#'
#' The labels can be inserted using [inline R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1) as follows:
#'
#'
#' ```r
#' #' @param start_date `r pkgsnippets::roxy_label("start_date", type = "param")`
#' #' @return `r pkgsnippets::roxy_label("data", type = "return")`
#' ```
#'
#' Note that the above only works in [roxygen2 7.1.0+](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/).
#' 
#' @param name The label name. See [roxy_labels()] for possible values.
#'
#' @return A character vector.
#' @keywords internal
#' @family roxygen2label
#' @export
roxy_label <- function(name = roxy_labels()$name) {
  
  dplyr::filter(.data = roxy_labels(),
                name == !!rlang::arg_match(name))$label
}

#' Get predefined parameter label
#'
#' These are pre-defined labels intended to be used to document function parameters using [roxygen2][roxygen2::roxygen2]'s
#' [`@param`](https://roxygen2.r-lib.org/articles/rd.html#functions) tag.
#'
#' The following parameter labels are available to be inserted using [inline R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1)
#' as follows:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' roxy_labels(type = "param") %$%
#'   name %>%
#'   purrr::map_chr(~ glue::glue(bt, bt, "#' @@param {.x} ", bt, 'r pkgsnippets::param_label("{.x}")', bt, " ", bt, bt)) %>%
#'   pal::cat_lines()
#' ```
#'
#' Note that the above only works in [roxygen2 7.1.0+](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/).
#' 
#' @inheritParams roxy_label
#'
#' @inherit roxy_label return
#' @family roxygen2label
#' @export
param_label <- function(name = roxy_labels(type = "param")$name) {
  
  dplyr::filter(.data = roxy_labels(type = "param"),
                name == !!rlang::arg_match(name)) %>%
    dplyr::arrange(type) %$%
    label %>%
    dplyr::first()
}

#' Get predefined return label
#'
#' These are pre-defined labels intended to be used to document function return values using [roxygen2][roxygen2::roxygen2]'s
#' [`@return`](https://roxygen2.r-lib.org/articles/rd.html#functions) tag.
#'
#' The following return labels are available to be inserted using [inline R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1)
#' as follows:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' roxy_labels(type = "return") %$%
#'   name %>%
#'   purrr::map_chr(~ glue::glue(bt, bt, "#' @@return ", bt, 'r pkgsnippets::return_label("{.x}")', bt, " ", bt, bt)) %>%
#'   pal::cat_lines()
#' ```
#'
#' Note that the above only works in [roxygen2 7.1.0+](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/).
#' 
#' @inheritParams roxy_label
#'
#' @inherit roxy_label return
#' @family roxygen2label
#' @export
return_label <- function(name = roxy_labels(type = "return")$name) {
  
  dplyr::filter(.data = roxy_labels(type = "return"),
                name == !!rlang::arg_match(name)) %>%
    dplyr::arrange(type) %$%
    label %>%
    dplyr::first()
}

#' Get a table of all available roxygen2 tag labels
#'
#' This simply returns a [tibble][tibble::tbl_df] listing all parameter labels included in this package, together with their `name` which can be provided as
#' the `name` argument of [param_label()] or [return_label()].
#'
#' Currently, parameter labels with the following `types` and `names` are available:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' roxy_labels() %>%
#'   dplyr::select(-label) %>%
#'   dplyr::mutate(dplyr::across(.fns = ~ paste0(bt, .x, bt))) %>%
#'   pal::pipe_table() %>%
#'   cat()
#' ```
#'
#' @param type The label type(s) to return. A character vector. Valid types include `"param"` and `"return"`.
#'
#' @return `r pkgsnippets::return_label("data")`
#' @family roxygen2label
#' @export
roxy_labels <- function(type = NULL) {
  
  tibble::tribble(
    ~type, ~name, ~label,
    NA, "data", "A [tibble][tibble::tbl_df].",
    NA, "path", "A [path][fs::fs_path].",
    NA, "r_object", "An \\R object.",
    NA, "version_nr", "A [numeric version][numeric_version()].",
    "param", "start_date", "The begin of the period the data covers. A [date](base::Date) or a character scalar in the format `\"YYYY-MM-DD\"`.",
    "param", "end_date", "The end of the period the data covers. A [date](base::Date) or a character scalar in the format `\"YYYY-MM-DD\"`.",
    "param", "use_cache", "Return cached results if possible. If `FALSE`, results are always newly fetched regardless of `cache_lifespan`.",
    "param", "cache_lifespan", paste0("The duration after which cached results are refreshed (i.e. newly fetched). A valid ",
                                      "[lubridate duration][lubridate::as.duration]. Only relevant if `use_cache = TRUE`.")
  ) %>%
    purrr::when(is.null(type) ~ .,
                ~ dplyr::filter(.data = .,
                                type %in% c({{type}}, NA)))
}

#' Get predefined R message
#'
#' @param name The message name. See [messages()] for possible values.
#' @param ... Further named arguments used to tailor the message to your needs. Not all messages require additional arguments, see [messages()] for an overview.
#'
#' @return A character scalar.
#' @family rmsg
#' @export
#'
#' @examples
#' pkgsnippets::msg(name = "pkg_required",
#'                  pkg = "some_pkg")
msg <- function(name = messages()$name,
                ...) {
  
  # ellipsis::check_dots_used()
  name <- rlang::arg_match(name)
  
  glue::glue(... = ...,
             dplyr::filter(.data = messages(),
                           name == !!name)$message)
}

#' Get a table of all R messages included in this package
#'
#' This simply returns a [tibble][tibble::tbl_df] listing all R messages together with their `name` which can be provided as [msg()]'s `name`
#' argument.
#'
#' Currently, R messages with the following `names` and `arguments` are available:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' messages() %>%
#'   dplyr::mutate(dplyr::across(.fns = ~ paste0(bt, .x, bt))) %>%
#'   add_args_col() %>%
#'   dplyr::select(-message) %>%
#'   pal::pipe_table() %>%
#'   cat()
#' ```
#'
#' @return `r pkgsnippets::return_label("data")`
#' @family rmsg
#' @export
messages <- function() {
  
  tibble::tribble(
    ~name, ~message,
    "pkg_required", "To be able to use this function, the package '{pkg}' is required but it is not installed. Please install it and then try again."
  )
}

add_args_col <- function(data) {
  
  dplyr::mutate(.data = data,
                arguments =
                  stringr::str_extract_all(string = message,
                                           pattern = "(?<=\\{)[^\\}]+?(?=\\})") %>%
                  pal::prose_ls(wrap = "`",
                                last_separator = ", "))
}
