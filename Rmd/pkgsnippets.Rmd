---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "label",
                                 "name",
                                 "path",
                                 "type"))
```

## Constants

```{r}
pkg <- utils::packageName()
```

# (R) Markdown snippets

## List all snippets shipped with this package

```{r}
#' List all snippets shipped with this package
#'
#' @return A vector of [paths]().
#' @export
ls_snippets <- function() {
  
  fs::path_package("snippets/",
                     package = pkg) %>%
    fs::dir_ls(recurse = TRUE,
               type = "file") %>%
    tibble::tibble(path = .) %>%
    dplyr::mutate(name = fs::path_file(path),
                  .before = 1L)
}
```

## Get snippet file path

TODO:

- Report child-document-working-dir problem to knitr: `r getwd()` in Rmd built with `pal::build_readme()` returns the path to `snippet_path()`-inserted knitr child document `/home/salim/.by_pkg_mngr/r/pkgsnippets/snippets/`! WTF?!
  
  The same `r getwd()` built with `devtools::build_readme()` gives nada.
  
  This has the consequence that DESCRIPTION file is not accessible via `desc::desc_get(desc::desc_fields())`.

  See <https://stackoverflow.com/a/32012827/7196903> for Yihui explaining that child docs get their own working dir and how to set knitr's `root.dir` option.
  But setting `knitr::opts_knit$set(root.dir = getwd())` in the parent `README.Rmd` does not change anything (and `devtools::build_rmd()` still outputs nada).
  Neither did using a relative child path, i.e. `child = fs::path_rel(pkgsnippets::snippet_path("installation-notice_dev-version_gitlab.Rmd"))`.

- Update the `@param name` doc as soon as [#1112](https://github.com/r-lib/roxygen2/issues/1112) is fixed!

```{r}
#' Get snippet file path
#'
#' This function gives the file path to an (R) Markdown snippet shipped with this package.
#'
#' The snippets can be used anywhere (R) Markdown input is supported. For example, you can use them as input to knitr's
#' [`child` document option](https://yihui.org/knitr/options/#child-documents):
#'
#' ```rmd
#' {r, child = pkgsnippets::snippet_path("installation-notice_dev-version_gitlab.Rmd")}
#' ```
#'
#' Or you can use them in roxygen2's [`@includeRmd` tag](https://roxygen2.r-lib.org/articles/rd.html#including-external--rmd-md-files):
#'
#' ```rmd
#' #' @includeRmd `pkgsnippets::snippet_path("installation-notice_dev-version_gitlab.Rmd")`
#' ```
#'
#' @param name The name of a snippet. Possible values include:
#'   00`r paste0('- ``"', ls_snippets()$name, '"``')`
#'
#' @return `r pkgsnippets::return_label("path")`
#' @export
#'
#' @examples
#' pkgsnippets::snippet_path("coding-style-notice.Rmd")
snippet_path <- function(name = ls_snippets()$name) {
  
  rlang::arg_match(name) %>%
    paste0("snippets/", .) %>%
    fs::path_package(package = pkg) %>%
    fs::path_real()
}
```

## Get predefined Markdown snippets

```{r}
#' Get predefined Markdown snippet
#'
#' @param name The snippet name.
#' @inherit param_label return
#' @export
md_snippet <- function(name = md_snippets()$name) {
  
  name <- rlang::arg_match(name)
  
  dplyr::filter(.data = md_snippets(),
                name == !!name)$label
  
  
}
```

## Get a table of all Markdown snippets included in this package

```{r}
#' Get a table of all Markdown snippets included in this package
#'
#' This simply returns a [tibble][tibble::tbl_df] listing all Markdown snippets together with their `name` which can be provided as [md_snippet()]'s `name`
#' argument.
#'
#' Currently, Markdown snippets with the following `names` are available:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' md_snippets() %>%
#'   dplyr::select(-label) %>%
#'   dplyr::mutate(dplyr::across(.fns = ~ paste0(bt, .x, bt))) %>%
#'   pal::pipe_table()
#' ```
#'
#' @return A [tibble][tibble::tbl_df].
#' @family roxygen2label
#' @export
md_snippets <- function() {
  
  tibble::tribble(
    ~name, ~label,
    "rstudio_addin_hint", paste0("This function is also registered as an [RStudio add-in](https://rstudio.github.io/rstudioaddins/) allowing RStudio users ",
                                 "to assign a custom shortcut to it.")
  )
}
```

# roxygen2 labels

## Get predefined parameter label

```{r}
#' Get predefined parameter label
#'
#' These are pre-defined labels intended to be used to document parameters using [roxygen2][roxygen2::roxygen2]'s
#' [`@param`](https://roxygen2.r-lib.org/articles/rd.html#functions) tags.
#'
#' The parameters can be inserted using [inline R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1) as follows:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' roxygen_labels() %>%
#'   dplyr::filter(type == "param") %$%
#'   name %>%
#'   purrr::map_chr(~ glue::glue(bt, bt, "#' @@param {.x} ", bt, 'r pkgsnippets::param_label("{.x}")', bt, " ", bt, bt, "\cr")) %>%
#'   pal::cat_lines()
#' ```
#'
#' Note that the above only works in [roxygen2 7.1.0+](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/).
#' 
#' @param name The label name. See [roxygen_labels()] for possible values.
#'
#' @return A character scalar.
#' @family roxygen2label
#' @export
param_label <- function(name = roxygen_labels(type = "param")$name) {
  
  name <- rlang::arg_match(name)
  
  dplyr::filter(.data = roxygen_labels(),
                type == "param" & name == !!name)$label
}
```

## Get predefined return label

```{r}
#' Get predefined return label
#'
#' These are pre-defined labels intended to be used to document function return values using [roxygen2][roxygen2::roxygen2]'s
#' [`@return`](https://roxygen2.r-lib.org/articles/rd.html#functions) tags.
#'
#' The parameters can be inserted using [inline R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1) as follows:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' roxygen_labels() %>%
#'   dplyr::filter(type == "return") %$%
#'   name %>%
#'   purrr::map_chr(~ glue::glue(bt, bt, "#' @@return ", bt, 'r pkgsnippets::return_label("{.x}")', bt, " ", bt, bt, "\cr")) %>%
#'   pal::cat_lines()
#' ```
#' 
#' @inheritParams param_label
#'
#' @inherit param_label return
#' @family roxygen2label
#' @export
return_label <- function(name = roxygen_labels(type = "return")$name) {
  
  name <- rlang::arg_match(name)
  
  dplyr::filter(.data = roxygen_labels(),
                type == "return" & name == !!name)$label
}
```

## Get a table of all roxygen labels included in this package

```{r}
#' Get a table of all roxygen labels included in this package
#'
#' This simply returns a [tibble][tibble::tbl_df] listing all parameter labels together with their `name` which can be provided as [param_label()]'s `name`
#' argument.
#'
#' Currently, parameter labels with the following `types` and `names` are available:
#'
#'
#' ```{r, echo = FALSE, results = "asis"}
#' bt <- "`"
#' roxygen_labels() %>%
#'   dplyr::select(-label) %>%
#'   dplyr::mutate(dplyr::across(.fns = ~ paste0(bt, .x, bt))) %>%
#'   pal::pipe_table()
#' ```
#'
#' @param type The label type(s) to return. A character vector. Valid types include
#'   ``r unique(roxygen_labels()$type) %>% pal::prose_ls(wrap = "`")``.
#' @return A [tibble][tibble::tbl_df].
#' @family roxygen2label
#' @export
roxygen_labels <- function(type = NULL) {
  
  tibble::tribble(
    ~type, ~name, ~label,
    "return", "data", "A [tibble][tibble::tbl_df].",
    "return", "path", "A [path][fs::fs_path()].",
    "param", "start_date", "The begin of the period the data covers. A [date](base::Date) or a character scalar in the format `\"YYYY-MM-DD\"`.",
    "param", "end_date", "The end of the period the data covers. A [date](base::Date) or a character scalar in the format `\"YYYY-MM-DD\"`.",
    "param", "use_cache", "Return cached results if possible. If `FALSE`, results are always newly fetched regardless of `cache_lifespan`.",
    "param", "cache_lifespan", paste0("The duration after which cached results are refreshed (i.e. newly fetched). A valid ",
                                      "[lubridate duration][lubridate::as.duration]. Defaults to 1 day (24 hours). Only relevant if `use_cache = TRUE`.")
  ) %>%
    purrr::when(is.null(type) ~ .,
                ~ dplyr::filter(.data = .,
                                type %in% {{type}}))
}
```
